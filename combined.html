<!DOCTYPE HTML>
<html>
	<head>
		<!-- Set the character encoding -->
		<meta charset="UTF-8">
		
		<!-- CSS -->
		<link type="text/css" rel="stylesheet" href="style.css" />
		
		<!-- Javascript -->
		<script type="text/javascript" src="scripts/protovis-r3.2.js"></script>
		<script type="text/javascript" src="scripts/jquery-1.4.2.min.js"></script>
		<script type="text/javascript" src="scripts/centroid.js"></script>
		<script type="text/javascript" src="scripts/us_lowres.js"></script>	 
		<script type="text/javascript" src="scripts/popupDiv.js"></script>
		<script type="text/javascript" src="stateOccupationData.js"></script>
		<script type="text/javascript" src="scripts/titleDescription.js"></script>		
		
		<!-- Title -->
		<title>Geo Tree Map</title>
		
	</head>
	<body>
		<!-- Data on demand popup window -->
		<div id="popupData"></div>
		<div id="titleDescription"></div>
		<form>
			<select id ="measureSelect" onchange="redrawMap();">
				<option value="total">Total
				<option value="annualMeanWage">Annual mean wage
				<option value="ann10Wage">10th percentile wage
				<option value="ann25Wage">25th percentile wage
				<option value="ann50Wage">50th percentile wage
				<option value="ann75Wage">75th percentile wage
				<option value="ann90Wage">90th percentile wage
			</select>
		</form>
		
		<!-- Protovis rendering -->
		<div id="fig">
			<script type="text/javascript">
		
var selectedOccupation = {
			category:"Management occupations",
			subcategory:"Chief executives"
		},
		selectedStateCode = "CA",
		selectedMeasure = "total";

function init() {
	var currentTagTokens = window.location.toString().split("?" );
	for ( var i = 1; i < currentTagTokens.length; i++ ) {
		var currentTag = currentTagTokens[i];
		var property = currentTag.substr(0, currentTag.indexOf('='));
		var value = currentTag.substr(currentTag.indexOf('=') + 1);
		if (property == "measure") {
			var selectBox = document.getElementById("measureSelect");
			selectedMeasure = value;
			selectBox.value = value;
		}
	}
}
init();

var width = 800,
		geoHeight = 400,
		treeHeight = 400,
		measureMaxVal = 0,
		measureMinVal = 0;

var geoScale;
var intervalScale;		
var geoColor;

function level(occupation) {
	var level = 1;
	
	if(occupation.subcategory) {
		level = 3;
	} else if(occupation.category) {
		level = 2;
	}
	
	return level;
}

function getValue(stateCode, occupation, measure) {
		var arrVal = stateOccupationData[measure + "_" + level(occupation)];
		
		// get the correct state
		var arrVal = arrVal[stateCode];
		
		// get the correct category
		if (occupation.category) {
			arrVal = arrVal[occupation.category];
		}
		
		// get the correct subcategory
		if (occupation.subcategory) {
			arrVal = arrVal[occupation.subcategory];
		}
		
		return arrVal;
}

function getAllValues(measure, occupation, stateCode) {
	if (stateCode) {
		return stateOccupationData[measure + "_" + level(occupation)][stateCode];
	} else {
		return stateOccupationData[measure + "_" + level(occupation)];
	}
}

// TODO: don't change globals as side effect of function
function findMaxMinValue(occupation, measure) {
	measureMaxVal = -1;
	measureMinVal = 1000000000000;
	var levelOccupationData = stateOccupationData[measure + "_" + level(occupation)];
	
	for (var key in levelOccupationData) {
		var arrVal = levelOccupationData[key];
		if (occupation.category) {
			arrVal = arrVal[occupation.category];
		}
		if (occupation.subcategory) {
			arrVal = arrVal[occupation.subcategory];
		}

		if (arrVal > measureMaxVal && arrVal >= 0) {
			measureMaxVal = arrVal
		}
		if (arrVal < measureMinVal && arrVal >= 0) {
			measureMinVal = arrVal
		}
	}
}

function initializeVars() {
	geoScale = pv.Geo.scale()
			.domain({lng: -128, lat: 24}, {lng: -64, lat: 50})
			.range({x: 0, y: 0}, {x: width, y: geoHeight});
	
	setTitleDescription("titleDescription", selectedMeasure, selectedOccupation);
	findMaxMinValue(selectedOccupation, selectedMeasure);
	
	intervalScale = (measureMaxVal - measureMinVal)/5;		
	geoColor = pv.Scale.linear(measureMinVal, measureMaxVal,(measureMaxVal - measureMinVal)/10).range("lightgreen","forestgreen");
}

initializeVars();




// Find the centroid for each state
us_lowres.forEach(function(c) {
	c.code = c.code.toUpperCase();
	c.centLatLon = centroid(c.borders[0]);
});


// Add the main panel
var vis = new pv.Panel()
		.width(width)
		.height(geoHeight + treeHeight)
		.top(30)
		.bottom(20);


// BEGIN GEO MAP

// Add a panel for each state
var statePanel = vis.add(pv.Panel)
		.data(us_lowres)
		.width(width)
		.height(geoHeight);

// Add a panel for each state land mass
statePanel.add(pv.Panel)
		.data(function(c) { return c.borders })
	.add(pv.Line)
		.data(function(l) { return l })
		.left(geoScale.x)
		.top(geoScale.y)
		.fillStyle(function(d, l, c) { return geoColor(getValue(c.code, selectedOccupation, selectedMeasure)) })
		.lineWidth(1)
		.strokeStyle("white")
		.antialias(false)
		.event("mouseover", function(d,l,c) { setVisible('popupData', c.code, selectedOccupation, true); this.fillStyle("blue"); return this; } )
		.event("mouseout", function(d, l, c) { setVisible('popupData', c.code, selectedOccupation, false); this.fillStyle(geoColor(getValue(c.code, selectedOccupation, selectedMeasure))); return this;} )
		.event("click", function(d, l,c) { alert("hello world"); return this; } );

//Add a label with the state code in the middle of every state
vis.add(pv.Label)
		.data(us_lowres)
		.left(function(c) { return geoScale(c.centLatLon).x })
		.top(function(c) { return geoScale(c.centLatLon).y })
		.text(function(c) { return c.code })
		.textAlign("center")
		.textBaseline("middle");

// Add the color bars for the color legend
console.log("measureMinVal: " + measureMinVal);
console.log("measureMaxVal: " + measureMaxVal);
console.log("intervalScale: " + intervalScale);
var bars = vis.add(pv.Bar)
		.data(pv.range(measureMinVal, measureMaxVal, intervalScale))
		.bottom(function(d) { return this.index * 12 + 40 + treeHeight + 30; })
		.height(10)
		.width(10)
		.left(width-100)
		.fillStyle(function(d) { return geoColor(measureMinVal + intervalScale * this.index) })
		.lineWidth(null)
	.anchor("right").add(pv.Label)
		.textAlign("left")
		.text(function(d) { return d + " - " + (d + intervalScale) + "" });


// BEGIN TREEMAP

var treeHover = -1,
		treeSelection = -1;

console.log("selectedMeasure: " + selectedMeasure);
console.log("selectedOccupation.category: " + selectedOccupation.category);
console.log("selectedOccupation.subcategory: " + selectedOccupation.subcategory);
console.log("selectedStateCode: " + selectedStateCode);

var treeColor = pv.Colors.category19().by(function(d) {
			switch (level) {
				case 1:
				case 2:
					return d.nodeName;
					break;
				case 3:
					return d.parentNode.nodeName;
					break;
			}
		}),
		nodes = pv.dom(getAllValues(selectedMeasure, selectedOccupation, selectedStateCode)).nodes();

var treemap = vis.add(pv.Layout.Treemap)
		.width(width)
		.height(treeHeight)
		.top(geoHeight+30)
		.nodes(nodes)
		.round(false)
		.padding(1);

treemap.leaf.add(pv.Panel)
		.fillStyle(function(d) { return d.index == treeHover ? treeColor(d).brighter() : treeColor(d); })
		.strokeStyle("white")
		.lineWidth(1)
		.antialias(false)
		.event("mouseover", function(d) { treeHover = d.index; return this; })
		.event("mouseout", function() { treeHover = -1; return this; });

treemap.label.add(pv.Label)
		.visible(function(d) {return d.parentNode && !d.parentNode.nodeName; })
		.textAngle(0)
		.textAlign("left")
		.textBaseline("top")
		.left(function(d) { return d.x; })
		.top(function(d) { return d.y; })
		.text(function(d) { return d.nodeName.substring(0,d.dx/10) + "..."; });


// REDRAW STUFF
function redrawMap() {
	var selectBox = document.getElementById("measureSelect");
	selectedMeasure = selectBox.options[selectBox.selectedIndex].value;
	//initializeVars();
	//bars.render();
	//statePanel.render();
	//vis.render();
	//statePanel.render();
	window.location = "index.html?measure=" + selectedMeasure;
}


// DRAW IT!
vis.render();

			</script>
		</div>
	</body>
</html>
