<!DOCTYPE HTML>
<html>
	<head>
		<!-- Set the character encoding -->
		<meta charset="UTF-8">
		
		<!-- CSS -->
		<link type="text/css" rel="stylesheet" href="style.css" />
		
		<!-- Javascript -->
		<script type="text/javascript" src="scripts/protovis-r3.2.js"></script>
		<script type="text/javascript" src="scripts/centroid.js"></script>
		<script type="text/javascript" src="scripts/us_lowres.js"></script>
		<script type="text/javascript" src="scripts/popupDiv.js"></script>
		<script type="text/javascript" src="stateOccupationData.js"></script>
		<script type="text/javascript" src="scripts/titleDescription.js"></script>		
		
		<!-- Title -->
		<title>Geo Tree Map</title>
		
	</head>
	<body>
		<!-- Data on demand popup window -->
		<div id="popupData"></div>
		<div id="titleDescription"></div>
		<form>
			<select id ="measureSelect" onchange="redrawMap();">
				<option value="total">Total
				<option value="annualMeanWage">Annual mean wage
				<option value="ann10Wage">10th percentile wage
				<option value="ann25Wage">25th percentile wage
				<option value="ann50Wage">50th percentile wage
				<option value="ann75Wage">75th percentile wage
				<option value="ann90Wage">90th percentile wage
			</select>
		</form>
		
		<!-- Protovis rendering -->
		<div id="fig">
			<script type="text/javascript">
		
var selectedOccupation = {
			category:"Management occupations",
			subcategory:"Chief executives"
		},
		selectedStateCode = "CA",
		selectedMeasure = "total";

function init() {
	var currentTagTokens = window.location.toString().split("?" );
	for ( var i = 1; i < currentTagTokens.length; i++ ) {
		var currentTag = currentTagTokens[i];
		var property = currentTag.substr(0, currentTag.indexOf('='));
		var value = currentTag.substr(currentTag.indexOf('=') + 1);
		if (property == "measure") {
			var selectBox = document.getElementById("measureSelect");
			selectedMeasure = value;
			selectBox.value = value;
		}
	}
}
init();

var width = 800,
		geoHeight = 400,
		treeHeight = 400,
		measureMaxVal = 0,
		measureMinVal = 0;
		
var geoScale;
var intervalScale;		
var geoColor;

function level(occupation) {
	var level = 1;
	
	if(occupation.subcategory) {
		level = 3;
	} else if(occupation.category) {
		level = 2;
	}
	
	return level;
}

function getValue(stateCode, occupation, measure) {
		var arrVal = stateOccupationData[measure + "_" + level(occupation)];
		
		// get the correct state
		var arrVal = arrVal[stateCode];
		
		// get the correct category
		if (occupation.category) {
			arrVal = arrVal[occupation.category];
		}
		
		// get the correct subcategory
		if (occupation.subcategory) {
			arrVal = arrVal[occupation.subcategory];
		}
		
		return arrVal;
}

function getAllValues(measure, occupation, stateCode) {
	if (stateCode) {
		return stateOccupationData[measure + "_" + level(occupation)][stateCode];
	} else {
		return stateOccupationData[measure + "_" + level(occupation)];
	}
}

// TODO: don't change globals as side effect of function
function findMaxMinValue(occupation, measure) {
	measureMaxVal = -1;
	measureMinVal = 1000000000000;
	var levelOccupationData = stateOccupationData[measure + "_" + level(occupation)];
	
	for (var key in levelOccupationData) {
		var arrVal = levelOccupationData[key];
		if (occupation.category) {
			arrVal = arrVal[occupation.category];
		}
		if (occupation.subcategory) {
			arrVal = arrVal[occupation.subcategory];
		}

		if (arrVal > measureMaxVal && arrVal >= 0) {
			measureMaxVal = arrVal
		}
		if (arrVal < measureMinVal && arrVal >= 0) {
			measureMinVal = arrVal
		}
	}
}

function initializeVars() {
	geoScale = pv.Geo.scale()
			.domain({lng: -128, lat: 24}, {lng: -64, lat: 50})
			.range({x: 0, y: 0}, {x: width, y: geoHeight});
	
	setTitleDescription("titleDescription", selectedMeasure, selectedOccupation);
	findMaxMinValue(selectedOccupation, selectedMeasure);
	
	intervalScale = (measureMaxVal - measureMinVal)/5;		
	geoColor = pv.Scale.linear(measureMinVal, measureMaxVal,(measureMaxVal - measureMinVal)/10).range("lightgreen","forestgreen");
}

initializeVars();


// Find the centroid for each state
us_lowres.forEach(function(c) {
	c.code = c.code.toUpperCase();
	c.centLatLon = centroid(c.borders[0]);
});


// Add the main panel
var vis = new pv.Panel()
		.width(width)
		.height(geoHeight + treeHeight + 60)
		.top(30)
		.bottom(0);


// BEGIN GEO MAP

var geoHover = "";

var statePanel,
		stateLabels,
		stateLegend;

// Add a panel for each state
statePanel = vis.add(pv.Panel)
		.data(us_lowres)
		.width(width)
		.height(geoHeight);

// Add a panel for each state land mass
statePanel.add(pv.Panel)
		.data(function(c) { return c.borders })
	.add(pv.Line)
		.data(function(l) { return l })
		.left(geoScale.x)
		.top(geoScale.y)
		.fillStyle(function(d, l, c) {
			return geoColor(getValue(c.code, selectedOccupation, selectedMeasure));
		})
		.lineWidth(1)
		.strokeStyle("white")
		.antialias(false)
		.event("mouseover", function(d, l, c) { setVisible('popupData', c, selectedOccupation, true); geoHover = c.code; return stateLabels; })
		.event("mouseout", function(d, l, c) { setVisible('popupData', c, selectedOccupation, false); geoHover = ""; return stateLabels; })
		.event("click", function(d, l, c) {
			selectedStateCode = c.code;
			nodes = pv.dom(getAllValues(selectedMeasure, selectedOccupation, selectedStateCode)).nodes();
			treemap.reset();
			treemap.render();
			return this;
		});

// Add a label with the state code in the middle of every state
stateLabels = vis.add(pv.Label)
		.data(us_lowres)
		.left(function(c) { return geoScale(c.centLatLon).x })
		.top(function(c) { return geoScale(c.centLatLon).y })
		.text(function(c) { return c.code })
		.textAlign("center")
		.textBaseline("middle")
		.textStyle(function(c) { return (geoHover == c.code || selectedStateCode == c.code) ? "red" : "black"; })
		.font(function(c) { return (geoHover == c.code || selectedStateCode == c.code) ? "bold 10px sans-serif" : "10px sans-serif"; });

// Add the color bars for the color legend
stateLegend = vis.add(pv.Bar)
		.data(pv.range(measureMinVal, measureMaxVal, intervalScale))
		.bottom(function(d) { return this.index * 12 + 40 + treeHeight + 30; })
		.height(10)
		.width(10)
		.left(width-100)
		.fillStyle(function(d) { return geoColor(measureMinVal + intervalScale * this.index) })
		.lineWidth(null)
	.anchor("right").add(pv.Label)
		.textAlign("left")
		.text(function(d) { 
			var textRangeMin = d;
			var textRangeMax = (d + intervalScale);
			if (intervalScale < 1) { 
				textRangeMin = textRangeMin.toPrecision(2); 
				textRangeMax = textRangeMax.toPrecision(2); } 
			else {
				textRangeMin = parseInt(textRangeMin); 
				textRangeMax = parseInt(textRangeMax); 
			} 
			return textRangeMin + " - " + textRangeMax + "" });


// BEGIN TREEMAP
function getNodes() {
	return nodes;
}
var treeHover = -1,
	treeSelection = -1;

var treeColor = pv.Colors.category19().by(function(d) {
			switch (level(selectedOccupation)) {
				case 1:
				case 2:
					return d.nodeName;
					break;
				case 3:
					return d.parentNode.nodeName;
					break;
			}
		}),
		nodes = pv.dom(getAllValues(selectedMeasure, selectedOccupation, selectedStateCode)).nodes();

var treemap = vis.add(pv.Layout.Treemap)
		.width(width)
		.height(treeHeight)
		.top(geoHeight+30)
		.nodes(getNodes)
		.round(false)
		.padding(1);

treemap.leaf.add(pv.Panel)
		.fillStyle(function(d) { return d.index == treeHover || d.index == treeSelection ? treeColor(d).brighter() : treeColor(d); })
		.strokeStyle("rgba(255,255,255,0.3)")
		.lineWidth(1)
		.antialias(false)
		.event("mouseover", function(d) { treeHover = d.index; return this; })
		.event("mouseout", function() { treeHover = -1; return this; })
		.event("click", function(d) {
			treeSelection = d.index;
			selectedOccupation.category = d.parentNode.nodeName;
			selectedOccupation.subcategory = d.nodeName;
			redrawMap();
			return this;
		});

treemap.label.add(pv.Label)
		.visible(function(d) {return d.parentNode && !d.parentNode.nodeName; })
		.textAngle(0)
		.textAlign("left")
		.textBaseline("top")
		.left(function(d) { return d.x; })
		.top(function(d) { return d.y; })
		.text(function(d) { return d.nodeName.substring(0,d.dx/8) + "..."; });


// BEGIN redraw code
function redrawMap() {
	var selectBox = document.getElementById("measureSelect");
	selectedMeasure = selectBox.options[selectBox.selectedIndex].value;
	initializeVars();
	stateLegend.data(pv.range(measureMinVal, measureMaxVal, intervalScale));
	vis.render();
	//window.location = "combined.html?measure=" + selectedMeasure;
}


// draw the vis
vis.render();

			</script>

		</div>

	</body>
</html>
