<!DOCTYPE HTML>
<html>
	<head>
		<!-- Set the character encoding -->
		<meta charset="UTF-8" />
		
		<!-- CSS -->
		<link type="text/css" rel="stylesheet" href="style.css" />
		
		<!-- Javascript -->
		<script type="text/javascript" src="scripts/protovis-r3.2.js"></script>
		<script type="text/javascript" src="scripts/centroid.js"></script>
		<script type="text/javascript" src="scripts/us_lowres.js"></script>
		<script type="text/javascript" src="scripts/popupDiv.js"></script>
		<script type="text/javascript" src="stateOccupationData.js"></script>
		<script type="text/javascript" src="scripts/titleDescription.js"></script>		
		
		<!-- Title -->
		<title>Geo Tree Map</title>
		
	</head>
	<body>
		<!-- Data on demand popup window -->
		<div id="popupData"></div>
		<div id="titleDescription"></div>
			<select id ="measureSelect" onchange="redrawMap(true, true);">
				<option value="total">Total</option>
				<option value="annualMeanWage">Annual mean wage</option>
				<option value="ann10Wage">10th percentile wage</option>
				<option value="ann25Wage">25th percentile wage</option>
				<option value="ann50Wage">50th percentile wage</option>
				<option value="ann75Wage">75th percentile wage</option>
				<option value="ann90Wage">90th percentile wage</option>
			</select>
			<select id="categorySelect" onchange="redrawMap(true, true);">
				<option value="categories">Categories</option>
				<option value="subcategories" selected="selected">Sub-Categories</option>
			</select>
		
		<!-- Protovis rendering -->
		<div id="fig">
			<script type="text/javascript">
			
var selectedOccupation = {
			category:"Computer and mathematical science occupations",
			subcategory:"Computer software engineers - applications"
		},
		selectedState = us_lowres[14],
		selectedMeasure = "total";

var width = 800,
		geoHeight = 400,
		treeHeight = 400,
		measureMaxVal = 0,
		measureMinVal = 0;
		
var geoScale;
var intervalScale;		
var geoColor;

function level(occupation) {
	var level = 1;
	
	if(occupation.subcategory) {
		level = 3;
	} else if(occupation.category) {
		level = 2;
	}
	
	return level;
}

function getValue(stateCode, occupation, measure) {
		var arrVal = stateOccupationData[measure + "_" + level(occupation)];
		
		// get the correct state
		var arrVal = arrVal[stateCode];
		
		// get the correct category
		if (occupation.category) {
			arrVal = arrVal[occupation.category];
		}
		
		// get the correct subcategory
		if (occupation.subcategory) {
			if (arrVal) {
				arrVal = arrVal[occupation.subcategory];
			} else {
				arrVal = -1;
			}
		}
		
		return arrVal;
}

function getAllValues(measure, occupation, stateCode) {
	if (stateCode) {
		return stateOccupationData[measure + "_" + level(occupation)][stateCode];
	} else {
		return stateOccupationData[measure + "_" + level(occupation)];
	}
}

// TODO: don't change globals as side effect of function
function findMaxMinValue(occupation, measure) {
	measureMaxVal = -Infinity;
	measureMinVal = Infinity;
	var levelOccupationData = stateOccupationData[measure + "_" + level(occupation)];
	
	for (var key in levelOccupationData) {
		var arrVal = levelOccupationData[key];
		if (occupation.category) {
			arrVal = arrVal[occupation.category];
		}
		if (occupation.subcategory) {
			if (arrVal) {
				arrVal = arrVal[occupation.subcategory];
			} else {
				arrVal = -1;
			}
		}
		if (arrVal > measureMaxVal && arrVal >= 0) {
			measureMaxVal = arrVal
		}
		if (arrVal < measureMinVal && arrVal >= 0) {
			measureMinVal = arrVal
		}
	}
}

function initializeVars() {
	geoScale = pv.Geo.scale()
			.domain({lng: -128, lat: 24}, {lng: -64, lat: 50})
			.range({x: 0, y: 0}, {x: width, y: geoHeight});
	
	setTitleDescription("titleDescription", selectedMeasure, selectedOccupation);
	findMaxMinValue(selectedOccupation, selectedMeasure);
	
	intervalScale = (measureMaxVal - measureMinVal)/5;		
	geoColor = pv.Scale.linear(measureMinVal, measureMaxVal,(measureMaxVal - measureMinVal)/10).range("lightgreen","forestgreen");
}

initializeVars();


// Find the centroid for each state
us_lowres.forEach(function(c) {
	c.code = c.code.toUpperCase();
	c.centLatLon = centroid(c.borders[0]);
});


// Add the main panel
var vis = new pv.Panel()
		.width(width)
		.height(geoHeight + treeHeight + 60)
		.top(30)
		.bottom(0);


// BEGIN GEO MAP

var geoHover = {};

var statePanel,
		stateLabels,
		stateLegend;

// Add a panel for each state
statePanel = vis.add(pv.Panel)
		.data(us_lowres)
		.width(width)
		.height(geoHeight);

// Add a panel for each state land mass
statePanel.add(pv.Panel)
		.data(function(c) { return c.borders })
	.add(pv.Line)
		.data(function(l) { return l })
		.left(geoScale.x)
		.top(geoScale.y)
		.fillStyle(function(d, l, c) {
			return geoColor(getValue(c.code, selectedOccupation, selectedMeasure));
		})
		.lineWidth(1)
		.strokeStyle("white")
		.antialias(false)
		.event("mouseover", function(d, l, c) { setVisible('popupData', c, selectedOccupation, true); geoHover = c; return stateLabels; })
		.event("mouseout", function(d, l, c) { setVisible('popupData', c, selectedOccupation, false); geoHover = {}; return stateLabels; })
		.event("click", function(d, l, c) {
			selectedState.code = c.code;
			redrawMap(false,true);
			return stateLabels;
		});

// Add a label with the state code in the middle of every state
stateLabels = vis.add(pv.Label)
		.data(us_lowres)
		.left(function(c) { return geoScale(c.centLatLon).x })
		.top(function(c) { return geoScale(c.centLatLon).y })
		.text(function(c) { return c.code })
		.textAlign("center")
		.textBaseline("middle")
		.textStyle(function(c) {
			if (selectedState.code == c.code) {
				return "red";
			} else if(geoHover.code == c.code) {
				return "blue";
			} else {
				return "black";
			}
		})
		.font(function(c) { return (geoHover.code == c.code || selectedState.code == c.code) ? "bold 10px sans-serif" : "10px sans-serif"; });

// Add the color bars for the color legend
stateLegend = vis.add(pv.Bar)
		.data(pv.range(measureMinVal, measureMaxVal, intervalScale))
		.bottom(function(d) { return this.index * 12 + 40 + treeHeight + 30; })
		.height(10)
		.width(10)
		.left(width-100)
		.fillStyle(function(d) { return geoColor(measureMinVal + intervalScale * this.index) })
		.lineWidth(null)
	.anchor("right").add(pv.Label)
		.textAlign("left")
		.text(function(d) { 
			var textRangeMin = d;
			var textRangeMax = (d + intervalScale);
			if (intervalScale < 1) { 
				textRangeMin = textRangeMin.toPrecision(2); 
				textRangeMax = textRangeMax.toPrecision(2); } 
			else {
				textRangeMin = parseInt(textRangeMin); 
				textRangeMax = parseInt(textRangeMax); 
			} 
			return textRangeMin + " - " + textRangeMax + "" });


// BEGIN TREEMAP
function getNodes() {
	return nodes;
}

function occupationForNode(node) {
	var occupation = {category:"", subcategory:""};
	
	if (node) {
		if (node.parentNode && node.parentNode.parentNode) {
			occupation.category = node.parentNode.nodeName;
			occupation.subcategory = node.nodeName;
		} else if (node.parentNode) {
			occupation.category = node.nodeName;
		}
	}
		
	return occupation;
}

function occupationsAreEqual(o1, o2) {
	return o1.category == o2.category && o1.subcategory == o2.subcategory;
}

function occupationMatchesNode(occupation, node) {
	return occupationsAreEqual(occupation, occupationForNode(node));
}

var treeHover = {category:"",subcategory:""};

var treeColor = pv.Colors.category19().by(function(d) {
			switch (level(selectedOccupation)) {
				case 1:
				case 2:
					return d.nodeName;
					break;
				case 3:
					return d.parentNode.nodeName;
					break;
			}
		}),
		nodes = pv.dom(getAllValues(selectedMeasure, selectedOccupation, selectedState.code)).nodes();

var treemap = vis.add(pv.Layout.Treemap)
		.width(width)
		.height(treeHeight)
		.top(geoHeight+30)
		.nodes(getNodes)
		.round(false)
		.padding(1);

treemap.leaf.add(pv.Panel)
		.fillStyle(function(d) { return occupationMatchesNode(treeHover,d) || occupationMatchesNode(selectedOccupation,d) ? treeColor(d).brighter() : treeColor(d); })
		.strokeStyle("rgba(255,255,255,0.3)")
		.lineWidth(1)
		.antialias(false)
		.event("mouseover", function(d) { setVisible('popupData', selectedState, occupationForNode(d), true); treeHover = occupationForNode(d); return this; })
		.event("mouseout", function(d) { setVisible('popupData', selectedState, occupationForNode(d), false); treeHover = occupationForNode(undefined); return this; })
		.event("click", function(d) {
			selectedOccupation = occupationForNode(d);
			redrawMap(true, false);
			return this;
		});

treemap.label.add(pv.Label)
		.visible(function(d) {return level(occupationForNode(d)) == 2; })
		.textAngle(0)
		.textAlign("left")
		.textBaseline("top")
		.left(function(d) { return d.x; })
		.top(function(d) { return d.y; })
		.text(function(d) { return d.nodeName.substring(0,d.dx/8) + "..."; });


// BEGIN redraw code
function redrawMap(geomapChange, treemapChange) {
	if (geomapChange && treemapChange) {
		var selectBox = document.getElementById("measureSelect");
		selectedMeasure = selectBox.options[selectBox.selectedIndex].value;
		selectBox = document.getElementById("categorySelect");
		selectedCategoryGroup = selectBox.options[selectBox.selectedIndex].value;
		if (selectedCategoryGroup == "subcategories") {
			var arrVal = stateOccupationData[selectedMeasure + "_" + 3];
			var arrVal = arrVal[selectedState.code];
			if (selectedOccupation.category) {
				arrVal = arrVal[selectedOccupation.category];
			}
			for (nextSubcategory in arrVal) {
				selectedOccupation.subcategory = nextSubcategory; 
				break;
			}
			
		} else {
			selectedOccupation.subcategory = undefined;
		}
		updateGeomap();
		updateTreemap();
	} else if (geomapChange) {
		updateGeomap();
	} else if (treemapChange) {
		updateTreemap();
	}
}
function updateGeomap() {
	initializeVars();
	stateLegend.data(pv.range(measureMinVal, measureMaxVal, intervalScale));
	statePanel.render();
}

function updateTreemap() {
	nodes = pv.dom(getAllValues(selectedMeasure, selectedOccupation, selectedState.code)).nodes();
	treemap.reset();
	treemap.render()
}

// draw the vis
vis.render();

			</script>

		</div>

	</body>
</html>
